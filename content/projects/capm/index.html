---
title: "Capital Asset Pricing Model"
author: "Yutao Jin"
date: "14 October 2020"
output:
  html_document:
    theme: flatly
    number_sections: yes
    toc: yes
    toc_float: yes
    code_folding: show
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<p><img src="capm.jpg" width="100%" style="display: block; margin: auto;" /></p>
<blockquote>
<p>Capital Asset Pricing Model (CAPM) is one of the most important models in finance and is the basic of many investment theorys. The model is specified as Ri=Rf+β(Rm-Rf)+e, where Ri is return of stock i, Rm is market average return, and Rf is riskfree rate. In investment evaluation, we always split our return into two parts: alpha return and beta return. Beta return is the incentive of taking systematic market risk and alpha return is generated by investors’ ability. Therefore, to evaluate whether investors beat the market, we must estimate the beta of their portfolios. In this blog, I use regression to estimate beta of stocks.</p>
</blockquote>
<div id="data-initialization" class="section level1">
<h1>Data Initialization</h1>
<p>I choose the <a href="https://en.wikipedia.org/wiki/Dow_Jones_Industrial_Average">Dow Jones Industrial Aveareg (DJIA)</a> stocks and their ticker symbols and download some data. Besides the thirty stocks that make up the DJIA, I will also add <code>SPY</code> which is an SP500 ETF (Exchange Traded Fund) as the market return.</p>
<pre class="r"><code>djia_url &lt;- &quot;https://en.wikipedia.org/wiki/Dow_Jones_Industrial_Average&quot;

# get tables that exist on URL
tables &lt;- djia_url %&gt;% 
  read_html() %&gt;% 
  html_nodes(css=&quot;table&quot;)

# parse HTML tables into a dataframe called djia. 
# Use purr::map() to create a list of all tables in URL
djia &lt;- map(tables, . %&gt;% 
               html_table(fill=TRUE)%&gt;% 
               clean_names())

# constituents
table1 &lt;- djia[[2]] %&gt;% # the second table on the page contains the ticker symbols
  mutate(date_added = ymd(date_added),
         
         # if a stock is listed on NYSE, its symbol is, e.g., NYSE: MMM
         # We will get prices from yahoo finance which requires just the ticker
         
         # if symbol contains &quot;NYSE*&quot;, the * being a wildcard
         # then we jsut drop the first 6 characters in that string
         ticker = ifelse(str_detect(symbol, &quot;NYSE*&quot;),
                          str_sub(symbol,7,11),
                          symbol)
         )

# we need a vector of strings with just the 30 tickers + SPY
tickers &lt;- table1 %&gt;% 
  select(ticker) %&gt;% 
  pull() %&gt;% # pull() gets them as a sting of characters
  c(&quot;SPY&quot;) # and lets us add SPY, the SP500 ETF</code></pre>
<p>Next I am going to download stock prices data using <code>tidyquant</code> package.</p>
<pre class="r"><code>myStocks &lt;- tickers %&gt;%
  tq_get(get  = &quot;stock.prices&quot;,
         from = &quot;2011-08-31&quot;,
         to   = &quot;2020-09-30&quot;) %&gt;%
  group_by(symbol) 

str(myStocks) # examine the structure of the resulting data frame</code></pre>
<pre><code>## tibble [68,937 x 8] (S3: grouped_df/tbl_df/tbl/data.frame)
##  $ symbol  : chr [1:68937] &quot;MMM&quot; &quot;MMM&quot; &quot;MMM&quot; &quot;MMM&quot; ...
##  $ date    : Date[1:68937], format: &quot;2011-08-31&quot; &quot;2011-09-01&quot; ...
##  $ open    : num [1:68937] 82.7 83 80 77.4 79.4 ...
##  $ high    : num [1:68937] 83.4 83.9 80.3 78.3 80.6 ...
##  $ low     : num [1:68937] 82.2 81.3 78.9 76.7 78.7 ...
##  $ close   : num [1:68937] 83 81.6 79.3 78.1 80.6 ...
##  $ volume  : num [1:68937] 4737700 4535400 4391300 5271200 5213800 ...
##  $ adjusted: num [1:68937] 65.1 64 62.2 61.3 63.2 ...
##  - attr(*, &quot;groups&quot;)= tibble [31 x 2] (S3: tbl_df/tbl/data.frame)
##   ..$ symbol: chr [1:31] &quot;AAPL&quot; &quot;AMGN&quot; &quot;AXP&quot; &quot;BA&quot; ...
##   ..$ .rows : list&lt;int&gt; [1:31] 
##   .. ..$ : int [1:2285] 6856 6857 6858 6859 6860 6861 6862 6863 6864 6865 ...
##   .. ..$ : int [1:2285] 4571 4572 4573 4574 4575 4576 4577 4578 4579 4580 ...
##   .. ..$ : int [1:2285] 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 ...
##   .. ..$ : int [1:2285] 9141 9142 9143 9144 9145 9146 9147 9148 9149 9150 ...
##   .. ..$ : int [1:2285] 11426 11427 11428 11429 11430 11431 11432 11433 11434 11435 ...
##   .. ..$ : int [1:2285] 48373 48374 48375 48376 48377 48378 48379 48380 48381 48382 ...
##   .. ..$ : int [1:2285] 15996 15997 15998 15999 16000 16001 16002 16003 16004 16005 ...
##   .. ..$ : int [1:2285] 13711 13712 13713 13714 13715 13716 13717 13718 13719 13720 ...
##   .. ..$ : int [1:2285] 64368 64369 64370 64371 64372 64373 64374 64375 64376 64377 ...
##   .. ..$ : int [1:387] 20566 20567 20568 20569 20570 20571 20572 20573 20574 20575 ...
##   .. ..$ : int [1:2285] 20953 20954 20955 20956 20957 20958 20959 20960 20961 20962 ...
##   .. ..$ : int [1:2285] 23238 23239 23240 23241 23242 23243 23244 23245 23246 23247 ...
##   .. ..$ : int [1:2285] 25523 25524 25525 25526 25527 25528 25529 25530 25531 25532 ...
##   .. ..$ : int [1:2285] 27808 27809 27810 27811 27812 27813 27814 27815 27816 27817 ...
##   .. ..$ : int [1:2285] 30093 30094 30095 30096 30097 30098 30099 30100 30101 30102 ...
##   .. ..$ : int [1:2285] 32378 32379 32380 32381 32382 32383 32384 32385 32386 32387 ...
##   .. ..$ : int [1:2285] 34663 34664 34665 34666 34667 34668 34669 34670 34671 34672 ...
##   .. ..$ : int [1:2285] 18281 18282 18283 18284 18285 18286 18287 18288 18289 18290 ...
##   .. ..$ : int [1:2285] 36948 36949 36950 36951 36952 36953 36954 36955 36956 36957 ...
##   .. ..$ : int [1:2285] 1 2 3 4 5 6 7 8 9 10 ...
##   .. ..$ : int [1:2285] 39233 39234 39235 39236 39237 39238 39239 39240 39241 39242 ...
##   .. ..$ : int [1:2285] 41518 41519 41520 41521 41522 41523 41524 41525 41526 41527 ...
##   .. ..$ : int [1:2285] 43803 43804 43805 43806 43807 43808 43809 43810 43811 43812 ...
##   .. ..$ : int [1:2285] 46088 46089 46090 46091 46092 46093 46094 46095 46096 46097 ...
##   .. ..$ : int [1:2285] 66653 66654 66655 66656 66657 66658 66659 66660 66661 66662 ...
##   .. ..$ : int [1:2285] 50658 50659 50660 50661 50662 50663 50664 50665 50666 50667 ...
##   .. ..$ : int [1:2285] 52943 52944 52945 52946 52947 52948 52949 52950 52951 52952 ...
##   .. ..$ : int [1:2285] 57513 57514 57515 57516 57517 57518 57519 57520 57521 57522 ...
##   .. ..$ : int [1:2285] 55228 55229 55230 55231 55232 55233 55234 55235 55236 55237 ...
##   .. ..$ : int [1:2285] 59798 59799 59800 59801 59802 59803 59804 59805 59806 59807 ...
##   .. ..$ : int [1:2285] 62083 62084 62085 62086 62087 62088 62089 62090 62091 62092 ...
##   .. ..@ ptype: int(0) 
##   ..- attr(*, &quot;.drop&quot;)= logi TRUE</code></pre>
<p>For each ticker symbol, the data frame contains its <code>symbol</code>, the <code>date</code>, the prices for <code>open</code>,<code>high</code>, <code>low</code> and <code>close</code>, and the <code>volume</code>, or how many stocks were traded on that day. More importantly, the data frame contains the <code>adjusted</code> closing price, which adjusts for any stock splits and/or dividends paid and this is what I will be using for my analyses.</p>
<p>The next step is to calculate returns based on closing price. I will use monthly return in my analyses.</p>
<pre class="r"><code>#calculate monthly  returns
myStocks_returns_monthly &lt;- myStocks %&gt;%
  tq_transmute(select     = adjusted, 
               mutate_fun = periodReturn, 
               period     = &quot;monthly&quot;, 
               type       = &quot;arithmetic&quot;,
               col_rename = &quot;monthly.returns&quot;) </code></pre>
<pre class="r"><code>#just keep the period returns grouped by symbol
monthly_capm_returns &lt;- myStocks_returns_monthly %&gt;%
            spread(key = symbol, value = monthly.returns)  </code></pre>
</div>
<div id="estimate-beta" class="section level1">
<h1>Estimate beta</h1>
<p>To simplify, I use the linear regression model specified as Ri=α+β*Rm. Firstly, I only focus on one stock: AAPL.</p>
<pre class="r"><code>ggplot(monthly_capm_returns, aes(x=SPY, y = AAPL))+
  geom_point()+
  geom_smooth(method=&quot;lm&quot;, se=FALSE)</code></pre>
<p><img src="/projects/capm/index_files/figure-html/unnamed-chunk-6-1.png" width="648" style="display: block; margin: auto;" /></p>
<pre class="r"><code>aapl_capm &lt;- lm(AAPL ~ SPY, data = monthly_capm_returns)
mosaic::msummary(aapl_capm)</code></pre>
<pre><code>##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  0.00990    0.00657    1.51     0.13    
## SPY          1.21579    0.16385    7.42  2.8e-11 ***
## 
## Residual standard error: 0.066 on 108 degrees of freedom
## Multiple R-squared:  0.338,  Adjusted R-squared:  0.332 
## F-statistic: 55.1 on 1 and 108 DF,  p-value: 2.83e-11</code></pre>
<pre class="r"><code>autoplot(aapl_capm)</code></pre>
<p><img src="/projects/capm/index_files/figure-html/unnamed-chunk-6-2.png" width="648" style="display: block; margin: auto;" /></p>
<p>The fitted model is Ri=0.0099+1.2158*Rm, where coefficient of Rm is significant at 1% level. I also plot the residuals vs. the fitted (or predicted) values. This is a standard regression diagnostic plot to check whether there is no pattern in the residuals, as well as to test for heteroscedasticity, or whether the residuals appear to have unequal, non-constant variance.</p>
<p>The second thing we must check is whether the residuals follow a Normal distribution. A normal scores, or a QQ plot, allows us to check for skewness, kurtosis and outliers. (Note that the heteroscedasticity may show as apparent non-normality.)</p>
<p>As we can see from the charts, there’s no pattern in the residuals and it follows a normal distribution.</p>
<p>However, it’s inefficient to conduct regression for each stock, especially when we have a large number of stocks to analyze. Actually, in <code>tidyquant</code> package, we can easily estimate <span class="math inline">\(\beta\)</span> for multiple stocks. To use the <code>tidyquant::tq_performance</code> function, I first rearrange the dataframe.</p>
<pre class="r"><code>capm_df&lt;-myStocks_returns_monthly %&gt;%
  filter(symbol!=&quot;SPY&quot;)

marketret&lt;-myStocks_returns_monthly %&gt;%
  filter(symbol==&quot;SPY&quot;) %&gt;%
  rename(marketret=monthly.returns)

capm_df&lt;-left_join(capm_df,marketret,by=&quot;date&quot;) %&gt;%
  select(symbol.x,date,monthly.returns,marketret) %&gt;%
  rename(symbol=symbol.x)</code></pre>
<p>Next, I use <code>tidyquant::tq_performance</code> to evaluate each stock performance with CAPM.</p>
<pre class="r"><code>capm_table&lt;-capm_df %&gt;%
  group_by(symbol) %&gt;%
  tq_performance(Ra=monthly.returns,
                 Rb=marketret,
                 performance_fun=table.CAPM)

capm_table</code></pre>
<pre><code>## # A tibble: 30 x 13
## # Groups:   symbol [30]
##    symbol ActivePremium    Alpha AnnualizedAlpha  Beta `Beta-` `Beta+`
##    &lt;chr&gt;          &lt;dbl&gt;    &lt;dbl&gt;           &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
##  1 MMM          -0.0352 -2.30e-3         -0.0267 1.03    0.876   0.932
##  2 AXP          -0.0458 -4.10e-3         -0.0477 1.15    1.61    0.761
##  3 AMGN          0.0676  8.50e-3          0.107  0.788   0.360   0.821
##  4 AAPL          0.142   9.90e-3          0.126  1.22    0.614   1.23 
##  5 BA           -0.0095  2.00e-4          0.0022 1.22    2.59    0.587
##  6 CAT          -0.0515 -4.40e-3         -0.052  1.24    0.730   1.04 
##  7 CVX          -0.134  -1.16e-2         -0.131  1.21    1.20    1.13 
##  8 CSCO         -0.0008  1.00e-3          0.0127 1.04    0.770   0.909
##  9 KO           -0.0652  3.00e-4          0.0031 0.562   0.862   0.323
## 10 DOW          -0.125  -1.39e-2         -0.155  1.80    1.10    1.55 
## # ... with 20 more rows, and 6 more variables: Correlation &lt;dbl&gt;,
## #   `Correlationp-value` &lt;dbl&gt;, InformationRatio &lt;dbl&gt;, `R-squared` &lt;dbl&gt;,
## #   TrackingError &lt;dbl&gt;, TreynorRatio &lt;dbl&gt;</code></pre>
<p>This table provides many other informative evaluating indicators such as Treynor Ratio. However, in this case, I only focus on Alpha and Beta.</p>
<pre class="r"><code>capm_table %&gt;%
  select(symbol,Alpha,Beta) %&gt;%
  arrange(desc(Beta))</code></pre>
<pre><code>## # A tibble: 30 x 3
## # Groups:   symbol [30]
##    symbol    Alpha  Beta
##    &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt;
##  1 DOW    -0.0139   1.80
##  2 GS     -0.0084   1.53
##  3 JPM    -0.00240  1.38
##  4 CRM     0.0065   1.36
##  5 CAT    -0.0044   1.24
##  6 BA      0.0002   1.22
##  7 AAPL    0.0099   1.22
##  8 CVX    -0.0116   1.21
##  9 DIS     0.0016   1.16
## 10 AXP    -0.0041   1.15
## # ... with 20 more rows</code></pre>
<pre class="r"><code>capm_table %&gt;%
  select(symbol,Alpha,Beta) %&gt;%
  arrange(desc(Alpha))</code></pre>
<pre><code>## # A tibble: 30 x 3
## # Groups:   symbol [30]
##    symbol  Alpha  Beta
##    &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;
##  1 UNH    0.0121 0.667
##  2 NKE    0.0119 0.707
##  3 V      0.0118 0.895
##  4 MSFT   0.0117 0.934
##  5 HD     0.0107 1.03 
##  6 AAPL   0.0099 1.22 
##  7 AMGN   0.0085 0.788
##  8 WMT    0.0078 0.355
##  9 MRK    0.0067 0.473
## 10 CRM    0.0065 1.36 
## # ... with 20 more rows</code></pre>
<p>The results show DOW, GS, and JPM are three stocks with highest Beta, while WMT, VZ, MRK are three stocks with lowest Beta. This provides some insights for investment decision. Generally speaking, during a bull market, we should buy stocks with high beta to benefit from overall market soaring while during the bear market, we should buy defending stocks, namely those stocks with low beta.</p>
<p>Another factor in CAPM is Alpha. As we can see from the table, UNH, NKE, and V are three stocks with highest Alpha, indicating these stocks have a premium over the market during the past 10 years. This may result from company’s growth potential and prospect.</p>
</div>
